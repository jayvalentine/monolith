{"version":3,"sources":["random.ts","language.ts"],"names":[],"mappings":"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","file":"language.f969acee.js","sourceRoot":"../src","sourcesContent":["export class Random {\n  static interval(min: number, max: number) : number {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  static choice<T>(array: T[]) : T {\n    const index = Random.interval(0, array.length - 1);\n    return array[index];\n  }\n\n  static chance(c: number) : boolean {\n    if (Math.random() < c) return true;\n    else return false;\n  }\n\n  static progressiveChance(c: number, progress: number, upperBound: number) : boolean {\n    const limit = Math.min(progress * c, upperBound);\n  \n    if (Math.random() < limit) return true;\n    else return false;\n  }\n}","import { Random } from \"./random\";\n\nconst Alphabet : string[] = []\n\nfor (let i = 0; i < 26; i++) {\n  Alphabet[i] = String.fromCharCode(97 + i);  \n}\n\nconst Vowel : string[] = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n\nconst Consonant : string[] = Alphabet.filter(function (v, i, a) {return (Vowel.indexOf(v) == -1)});\n\nclass Suffix {\n    public readonly suffix : string;\n    public readonly optional : string;\n\n    constructor(suffix: string, optional: string) {\n        this.suffix = suffix;\n        this.optional = optional;\n    }\n}\n\nexport class Noun {\n    public readonly base : string;\n    \n    public readonly plural : boolean;\n    public readonly genitive : boolean;\n    \n    public readonly adjectives : string[];\n\n    constructor(base: string, plural: boolean, genitive: boolean, adjectives: string[]) {\n        this.base = base;\n        this.plural = plural;\n        this.genitive = genitive;\n        this.adjectives = adjectives;\n    }\n}\n\nexport class Language {\n    public static capitalize(word: string) : string {\n        let restOfWord : string = word.slice(1);\n        return word.charAt(0).toUpperCase() + restOfWord;\n    }\n\n    public static toTitle(sentence: string) : string {\n      return sentence.split(' ').map(Language.capitalize).join(' ');\n    }\n\n    private static getSuffix() : Suffix {\n        let optional : string = Random.choice(Vowel);\n\n        let suffix : string = Random.choice(Consonant) + Random.choice(Vowel);\n\n        return new Suffix(suffix, optional);\n    }\n\n    private static addSuffix(word: string, suffix: Suffix) : string {\n        if (Consonant.indexOf(word[word.length-1]) > -1) {\n            word += suffix.optional;\n        }\n        word += suffix.suffix;\n\n        return word;\n    }\n\n    private readonly plural : Suffix;\n    private readonly genitive : Suffix;\n    private readonly adjective : Suffix;\n\n    private readonly adjectivePolicy : Language.Position;\n\n    private translations : Object;\n\n    constructor() {\n        this.plural = Language.getSuffix();\n        this.genitive = Language.getSuffix();\n        this.adjective = Language.getSuffix();\n\n        if (Random.chance(0.5)) {\n            this.adjectivePolicy = Language.Position.Before;\n        }\n        else {\n            this.adjectivePolicy = Language.Position.After;\n        }\n\n        this.translations = {};\n    }\n\n    translate(sentence: Noun[]) : string {\n        let sentenceTranslated : string[] = [];\n        \n        for (let word of sentence) {\n            let wordTranslated : string = this.translateWord(word.base);\n\n            if (word.plural) wordTranslated = Language.addSuffix(wordTranslated, this.plural);\n            if (word.genitive) wordTranslated = Language.addSuffix(wordTranslated, this.genitive);\n\n            let adjectives : string[] = []\n            for (let adj of word.adjectives) {\n                let adjTranslated = this.translateWord(adj);\n\n                adjTranslated = Language.addSuffix(adjTranslated, this.adjective);\n\n                adjectives.push(adjTranslated);\n            }\n\n            if (this.adjectivePolicy == Language.Position.Before) {\n                sentenceTranslated = sentenceTranslated.concat(adjectives);\n            }\n\n            sentenceTranslated.push(wordTranslated);\n\n            if (this.adjectivePolicy == Language.Position.After) {\n                sentenceTranslated = sentenceTranslated.concat(adjectives);\n            }\n        }\n\n        return sentenceTranslated.join(\" \");\n    }\n\n    private translateWord(word: string) {\n        // First split word into phonemes.\n        let phonemes : string[] = [];\n\n        let currentPhoneme : string = \"\";\n\n        for (let letter of word.split('')) {\n            if (currentPhoneme.length > 0) {\n                let lastLetter = currentPhoneme[currentPhoneme.length - 1];\n\n                if (Vowel.indexOf(lastLetter) > -1) {\n                    phonemes.push(currentPhoneme);\n                    currentPhoneme = \"\";\n                }\n                else if ((Consonant.indexOf(lastLetter) > -1) && (Consonant.indexOf(letter) > -1)) {\n                    if (lastLetter != letter) {\n                        phonemes.push(currentPhoneme);\n                        currentPhoneme = \"\";\n                    }\n                }\n            }\n\n            currentPhoneme += letter;\n        }\n\n        if (currentPhoneme.length > 0) phonemes.push(currentPhoneme);\n\n        // Translate each phoneme.\n        let wordTranslated : string = \"\";\n\n        for (let p of phonemes) {\n            wordTranslated += this.translatePhoneme(p);\n        }\n\n        return wordTranslated;\n    }\n\n    private translatePhoneme(phoneme: string) {\n        if (!this.translations.hasOwnProperty(phoneme)) {\n            let t : string = \"\";\n\n            for (let letter of phoneme.split('')) {\n                if (Consonant.indexOf(letter) > -1) t += Random.choice(Consonant);\n                else t += Random.choice(Vowel);\n            }\n\n            this.translations[phoneme] = t;\n        }\n\n        return this.translations[phoneme];\n    }\n}\n\nexport namespace Language {\n    export enum Position {\n        Before = \"Before\",\n        After = \"After\",\n    }\n}"]}