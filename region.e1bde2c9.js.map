{"version":3,"sources":["random.ts","region.ts"],"names":[],"mappings":"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","file":"region.e1bde2c9.js","sourceRoot":"../src","sourcesContent":["export class Random {\n  static interval(min: number, max: number) : number {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  static choice<T>(array: T[]) : T {\n    const index = Random.interval(0, array.length - 1);\n    return array[index];\n  }\n\n  static chance(c: number) : boolean {\n    if (Math.random() < c) return true;\n    else return false;\n  }\n\n  static progressiveChance(c: number, progress: number, upperBound: number) : boolean {\n    const limit = Math.min(progress * c, upperBound);\n  \n    if (Math.random() < limit) return true;\n    else return false;\n  }\n}","import { Random } from \"./random\";\nimport { Tribe } from \"./tribe\";\n\n// A region is a part of the world that can be inhabited by tribes.\n//\n// Regions have three statistics:\n// food: level of food available in the region.\n// water: level of water available in the region.\n// resources: level of resources available in the region.\nexport class Region {\n  private _food: number;\n  private _water: number;\n  private _resources: number;\n\n  private _type: Region.Type;\n\n  private _tribes: Tribe[];\n\n  private _nearbyRegions: Region[];\n\n  private _structures: string[];\n\n  public hasMonolith: boolean;\n\n  // Given a level number, returns a string description.\n  private levelString(level : number) : string {\n    switch(level)\n    {\n      case 0: return \"no\";\n      case 1: return \"scarce\";\n      case 2: return \"barely adequate\";\n      case 3: return \"adequate\";\n      case 4: return \"sufficient\";\n      case 5: return \"plentiful\";\n      case 6: return \"abundant\";\n    }\n\n    return \"INVALID\";\n  }\n\n  constructor() {\n    this.hasMonolith = false;\n    this._tribes = [];\n    this._nearbyRegions = [];\n    this._structures = [];\n\n    // Choose a random type for the region.\n    let t = Random.interval(0, 6);\n    this._type = Region.Type.Undefined;\n\n    switch(t) {\n      case 0: this._type = Region.Type.Desert; break;\n      case 1: this._type = Region.Type.Grassland; break;\n      case 2: this._type = Region.Type.Hills; break;\n      case 3: this._type = Region.Type.Mountains; break;\n      case 4: this._type = Region.Type.Tundra; break;\n      case 5: this._type = Region.Type.Valley; break;\n      case 6: this._type = Region.Type.Rainforest; break;\n    }\n\n    // Determine food, water, resource levels.\n    // We generate a number between 2 and 4, which is then augmented by the type.\n    this._food = Random.interval(2, 4);\n    this._water = Random.interval(2, 4);\n    this._resources = Random.interval(2, 4);\n  }\n\n  // Returns the type of the region.\n  type() : Region.Type {\n    return this._type;\n  }\n\n  typeString() : string {\n    return Region.Type[this._type];\n  }\n\n  typeStringLowercase() : string {\n    switch(this._type) {\n      case Region.Type.Desert: return \"desert\";\n      case Region.Type.Grassland: return \"grassland\";\n      case Region.Type.Hills: return \"hills\";\n      case Region.Type.Mountains: return \"mountains\";\n      case Region.Type.Tundra: return \"tundra\";\n      case Region.Type.Valley: return \"valley\";\n      case Region.Type.Rainforest: return \"rainforest\";\n      case Region.Type.Undefined: return \"UNDEFINED\";\n    }\n  }\n\n  // Returns the string description of the region's type.\n  typeDescription() : string {\n    switch(this._type) {\n      case Region.Type.Desert: return \"desert\";\n      case Region.Type.Grassland: return \"grassland\";\n      case Region.Type.Hills: return \"hilly\";\n      case Region.Type.Mountains: return \"mountainous\";\n      case Region.Type.Tundra: return \"tundra\";\n      case Region.Type.Valley: return \"valley\";\n      case Region.Type.Rainforest: return \"rainforest\";\n      case Region.Type.Undefined: return \"UNDEFINED\";\n    }\n  }\n\n  // Returns the food level of the region, with the type modifier.\n  food() : number {\n    switch(this._type) {\n      case Region.Type.Desert: return this._food - 1;\n      case Region.Type.Grassland: return this._food + 1;\n      case Region.Type.Hills: return this._food;\n      case Region.Type.Mountains: return this._food - 2;\n      case Region.Type.Tundra: return this._food - 1;\n      case Region.Type.Valley: return this._food + 1;\n      case Region.Type.Rainforest: return this._food + 2;\n      case Region.Type.Undefined: return 0;\n    }\n  }\n\n  // Returns a string representation of the region's food level.\n  foodString() : string {\n    return this.levelString(this.food());\n  }\n\n  // Returns the water level of the region, with the type modifier.\n  water() : number {\n    switch(this._type) {\n      case Region.Type.Desert: return this._water - 2;\n      case Region.Type.Grassland: return this._water;\n      case Region.Type.Hills: return this._water + 1;\n      case Region.Type.Mountains: return this._water - 1;\n      case Region.Type.Tundra: return this._water - 1;\n      case Region.Type.Valley: return this._water + 2;\n      case Region.Type.Rainforest: return this._water;\n      case Region.Type.Undefined: return 0;\n    }\n  }\n\n  // Returns a string representation of the region's water level.\n  waterString() : string {\n    return this.levelString(this.water());\n  }\n\n  // Returns the resource level of the region, with the type modifier.\n  resources() : number {\n    switch(this._type) {\n      case Region.Type.Desert: return this._resources + 1;\n      case Region.Type.Grassland: return this._resources - 2;\n      case Region.Type.Hills: return this._resources + 1;\n      case Region.Type.Mountains: return this._resources + 2;\n      case Region.Type.Tundra: return this._resources;\n      case Region.Type.Valley: return this._resources - 1;\n      case Region.Type.Rainforest: return this._resources;\n      case Region.Type.Undefined: return 0;\n    }\n  }\n\n  // Returns a string representation of the region's resources level.\n  resourcesString() : string {\n    return this.levelString(this.resources());\n  }\n\n  // Returns the number of tribes in this region.\n  tribesCount() : number {\n    return this._tribes.length;\n  }\n\n  // Returns a list of tribes in this region.\n  tribes() : Tribe[] {\n    return this._tribes;\n  }\n\n  // Returns the population of this region.\n  population() : number {\n    let sum : number = 0;\n\n    for (let t of this._tribes) {\n      sum += t.population();\n    }\n\n    return sum;\n  }\n\n  // Adds a tribe to this region.\n  addTribe(tribe: Tribe) {\n    this._tribes.push(tribe);\n  }\n\n  // Removes a tribe from this region.\n  // Exits silently if the tribe isn't in the region.\n  removeTribe(tribe: Tribe) {\n    const index = this._tribes.indexOf(tribe);\n\n    if (index >= 0) {\n      this._tribes.splice(index, 1);\n    }\n  }\n\n  addNearbyRegion(region: Region) {\n    // Do nothing if we've already added this region.\n    if (this._nearbyRegions.indexOf(region) > -1) return;\n\n    // Add the other region.\n    this._nearbyRegions.push(region);\n\n    // Call addNearbyRegion for the other region, passing this.\n    region.addNearbyRegion(this);\n  }\n\n  nearby() : Region[] {\n    return this._nearbyRegions;\n  }\n\n  addStructure(structure: string) {\n    if (this._structures.indexOf(structure) > -1) return;\n    else this._structures.push(structure);\n  }\n\n  hasStructure(structure: string) : boolean {\n    if (this._structures.indexOf(structure) > -1) return true;\n    else return false;\n  }\n}\n\nexport namespace Region {\n  export enum Type {\n    Desert = \"Desert\",\n    Grassland = \"Grassland\",\n    Hills = \"Hills\",\n    Mountains = \"Mountains\",\n    Tundra = \"Tundra\",\n    Valley = \"Valley\",\n    Rainforest = \"Rainforest\",\n    Undefined = \"Undefined\"\n  }\n}\n"]}